import os # This is used to access environment variable
import requests
from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer # a module to provide us with a sentiment score of a user's post
from dotenv import load_dotenv
import random

# Load environment variables from .env file
load_dotenv()

# Access API key from the environment variable
RAPIDAPI_KEY = os.environ.get('RAPIDAPI_KEY')
# RAPIDAPI_KEY = "f6861a6851msh4a539514036d796p13f225jsn55c3f8caa100" # will be removed and kept in .env file

"""
This file contains two connected classes:
SentimentAnalysis  
    - Reads the user’s post  
    - Uses VADER (a sentiment analysis tool) to label the text as:
        • Positive  
        • Negative  
        • Neutral  
    - This label helps us choose an affirmation that matches the user’s mood.

Affirmations  
    - Takes the sentiment label  
    - Maps it to an affirmation category (e.g., love, gratitude, sleep)  
    - Sends a request to a RapidAPI endpoint  
    - Returns a personalised affirmation back to the user
Both classes work together to create a gentle, tailored user experience.
"""

# -------------------------------------------------------------------------
# SENTIMENT ANALYSIS CLASS
# -------------------------------------------------------------------------
class SentimentAnalysis:
    """
    Analyses how positive or negative a piece of text feels.
    Uses VADER sentiment scoring to return one of three labels.
    """
    def __init__(self, label):
        self.analyzer = SentimentIntensityAnalyzer()
        self.label = None

    def text_analysis(self, text):
        """
        Runs sentiment analysis on the user's post.
        STEPS:
        1. VADER produces a score between -1 (very negative) and +1 (very positive).
        2. We look at the 'compound' score.
        3. Based on its value, we choose a label:
        - Positive  → score >= 0.05
        - Negative  → score <= -0.05
        - Neutral   → otherwise
        Returns: A string representing the sentiment label.
        """
        score = self.analyzer.polarity_scores(text) # This returns a dictionary
        compound_score = score["compound"]
        if compound_score >= 0.05:
            self.label = "Positive"
        elif compound_score <= -0.05:
            self.label = "Negative"
        else:
            self.label = "Neutral"
        
        return self.label

# -------------------------------------------------------------------------
# AFFIRMATION API CLASS
# -------------------------------------------------------------------------
# Secondly, we have writen a further class to send requests to RAPID API, which is an API which provides affirmations
# that have been categorised by things like love, health, happiness. The labels returned from the sentiment correspond
# with different affirmation categories, to make them more personalised to the user's mood.

API_HOST = "affirmations-api-by-apirobots.p.rapidapi.com"
BASE_URL = "https://affirmations-api-by-apirobots.p.rapidapi.com/v1/affirmations/categories"

headers = {
    "x-rapidapi-key": RAPIDAPI_KEY,
    "x-rapidapi-host": API_HOST
}

# This class has a method to send requests to get affirmations by the category endpoint.
class Affirmations(SentimentAnalysis):
    """
    Uses the sentiment label from SentimentAnalysis
    to choose an affirmation category and request a personalised message.
    """
    def __init__(self):
        super().__init__(self)

    # This method takes the label generated by the sentiment analysis and matches it with certain affirmation categories
    def affirmation_category(self):
        """
        Maps the sentiment label to a suitable affirmation category.
        Examples:
        - Positive mood → uplifting affirmations (love, happiness, beauty)
        - Negative mood → grounding or soothing affirmations (gratitude, sleep)
        - Neutral mood → any category
        Returns: A randomly selected category.
        """
        if self.label == "Positive":
            cats = ["love", "health", "beauty", "happiness", "money", "blessing"]
        elif self.label == "Negative":
            cats = ['gratitude', 'spiritual', 'blessing', 'sleep']
        else:
            cats = ['love', 'health', 'beauty', 'gratitude', 'spiritual', 'happiness', 'money', 'blessing', 'sleep']
        return random.choice(cats)

    # This method calls the API to provide an affirmation from a specific category
    def get_affirmation(self, category):
        """
        Calls the RapidAPI endpoint to fetch a random affirmation
        from the selected category.
        Returns: A string containing the affirmation text.
        If the API is unavailable, returns a friendly fallback message.
        """
        try:
            url = f"{BASE_URL}/{category}/random"
            response = requests.get(url, headers=headers)
            response.raise_for_status()
            res = response.json()
            return res["text"]
        except Exception as e:
            print("Error with API service, apologies.", e)
            return "All is good. Take a breath, you matter"

    # This function pieces everything together, by firstly using the text_analysis function in the sentiment analysis class
    # to produce a label, then calling on the affirmation_category function above to link the label with a category, then finally
    # the return line inserts that category in to the get_affirmation function, to provide an affirmation within the chosen category
    def personalised_affirmation(self, text):
        """
        Combines the entire pipeline:
        1. Analyse the user’s post → get sentiment label.
        2. Pick an affirmation category based on that label.
        3. Request an affirmation from the API.
        4. Return that personalised affirmation.
        Returns: A string containing the chosen affirmation.
        """
        self.text_analysis(text)
        category = self.affirmation_category()
        return self.get_affirmation(category)


